import topology.compact_open
import topology.uniform_space.basic
import topology.order

universes u‚ÇÅ u‚ÇÇ

open_locale filter uniformity topological_space
open uniform_space set

variables {Œ± : Type u‚ÇÅ} {Œ≤ : Type u‚ÇÇ} [topological_space Œ±] [uniform_space Œ≤]
variables (K : set Œ±) (V : set (Œ≤ √ó Œ≤)) (f : C(Œ±, Œ≤))

/-- A subbase for the topology of compact convergence. -/
def uniform_gen : set C(Œ±, Œ≤) := {g | ‚àÄ (x ‚àà K), (f x, g x) ‚àà V }

/-- The topology of compact convergence. I claim this topology is induced by a uniform structure,
defined below. -/
def compact_convergence_topology : topological_space C(Œ±, Œ≤) :=
topological_space.generate_from
  {m | ‚àÉ (K : set Œ±) (hK : is_compact K) (V ‚àà ùì§ Œ≤) (hV : is_open V) (f : C(Œ±, Œ≤)),
       m = uniform_gen K V f }

lemma mem_uniform_gen_self (hV : V ‚àà ùì§ Œ≤) : f ‚àà uniform_gen K V f := Œª x hx, refl_mem_uniformity hV

/-- This should be sufficient to show we actually have a neighbourhood basis. -/
lemma uniform_gen_nhd_basis {g‚ÇÅ g‚ÇÇ : C(Œ±, Œ≤)} (V' : set (Œ≤ √ó Œ≤))
  (h‚ÇÅ : g‚ÇÅ ‚àà uniform_gen K V f) (h‚ÇÇ : g‚ÇÇ ‚àà uniform_gen K V' g‚ÇÅ) :
  g‚ÇÇ ‚àà uniform_gen K (V ‚óã V') f :=
Œª x hx, ‚ü®g‚ÇÅ x, h‚ÇÅ x hx, h‚ÇÇ x hx‚ü©

lemma uniform_gen_mono (V' : set (Œ≤ √ó Œ≤)) (hV' : V' ‚äÜ V) :
  uniform_gen K V' f ‚äÜ uniform_gen K V f :=
Œª x hx a ha, hV' (hx a ha)

-- I'm not confident this is true but I think some variant of it should be the
-- right idea. For example in the case that `Œ≤` is a metric space and `V` is
-- the open entourage of points a distance at most `Œµ` then the conclusion
-- holds (because `k ‚Ü¶ dist (f k) (g k)` is continuous on `K` and so
-- achieves its bound `Œ¥`, say. Since `Œ¥ < Œµ`. We can then define `W`, `W'` as
-- entourages of points whose distances are less than some value above `Œ¥` and
-- some value just below `Œµ - Œ¥` respectively).
lemma uniform_gen_foo (hK : is_compact K) (V ‚àà ùì§ Œ≤) (hV : is_open V)
  {g : C(Œ±, Œ≤)} (h : g ‚àà uniform_gen K V f) :
  ‚àÉ (W W' ‚àà ùì§ Œ≤), W ‚óã W' ‚äÜ V ‚àß g ‚àà uniform_gen K W f :=
begin
  have h' : (Œª x, (f x, g x))'' K ‚äÜ V, { rintros b ‚ü®a, ha, rfl‚ü©, exact h a ha, },
  obtain ‚ü®Z, hZ‚ÇÅ, hZ‚ÇÇ, hZ‚ÇÉ‚ü© :=
    lebesgue_number_of_compact_open (hK.image (f.continuous.prod_mk g.continuous)) hV h',
  have hZ‚ÇÉ' : ‚àÄ (x ‚àà K) b, ((f x, g x), b) ‚àà Z ‚Üí b ‚àà V,
  { simp only [mem_image, and_imp, prod.forall, forall_exists_index, prod.mk.inj_iff] at hZ‚ÇÉ,
    exact Œª x hx, hZ‚ÇÉ (f x) (g x) x hx rfl rfl, },
  clear hZ‚ÇÉ,
  -- hmm, out of time and more thought required :-/
  sorry,
end

/-- Any point of `compact_open.gen K U` is also an interior point wrt the topology of compact
convergence.

The topology of compact convergence is thus at least as fine as the compact-open topology. -/
lemma uniform_gen_subset_compact_open (hK : is_compact K) {U : set Œ≤} (hU : is_open U)
  (hf : f ‚àà continuous_map.compact_open.gen K U) :
  ‚àÉ (V ‚àà ùì§ Œ≤), is_open V ‚àß uniform_gen K V f ‚äÜ continuous_map.compact_open.gen K U :=
begin
  obtain ‚ü®V, hV‚ÇÅ, hV‚ÇÇ, hV‚ÇÉ‚ü© := lebesgue_number_of_compact_open (hK.image f.continuous) hU hf,
  refine ‚ü®V, hV‚ÇÅ, hV‚ÇÇ, _‚ü©,
  rintros g hg - ‚ü®x, hx, rfl‚ü©,
  exact hV‚ÇÉ (f x) ‚ü®x, hx, rfl‚ü© (hg x hx),
end

/-- The point `f` in `uniform_gen K V f` is also an interior point wrt the compact-open topology.

From this it should follow that the compact-open topology is at least as fine as the topology of
compact convergence. -/
lemma Inter_compact_open_gen_subset_uniform_gen (hK : is_compact K) (hV : V ‚àà ùì§ Œ≤) :
  ‚àÉ (Œπ : Sort (u‚ÇÅ + 1)) [fintype Œπ]
  (C : Œπ ‚Üí set Œ±) (hC : ‚àÄ i, is_compact (C i))
  (U : Œπ ‚Üí set Œ≤) (hU : ‚àÄ i, is_open (U i)),
  (f ‚àà ‚ãÇ i, continuous_map.compact_open.gen (C i) (U i)) ‚àß
  (‚ãÇ i, continuous_map.compact_open.gen (C i) (U i)) ‚äÜ uniform_gen K V f :=
begin
  obtain ‚ü®W, hW‚ÇÅ, hW‚ÇÑ, hW‚ÇÇ, hW‚ÇÉ‚ü© := comp_open_symm_mem_uniformity_sets hV,
  obtain ‚ü®Z, hZ‚ÇÅ, hZ‚ÇÑ, hZ‚ÇÇ, hZ‚ÇÉ‚ü© := comp_open_symm_mem_uniformity_sets hW‚ÇÅ,
  let U : Œ± ‚Üí set Œ± := Œª x, f‚Åª¬π' (ball (f x) Z),
  have hU : ‚àÄ x, is_open (U x) := Œª x, f.continuous.is_open_preimage _ (is_open_ball _ hZ‚ÇÑ),
  have hUK : K ‚äÜ ‚ãÉ (x : K), U (x : K),
  { intros x hx,
    simp only [exists_prop, mem_Union, Union_coe_set, mem_preimage],
    use (‚ü®x, hx‚ü© : K),
    simp [hx, mem_ball_self (f x) hZ‚ÇÅ], },
  obtain ‚ü®t, ht‚ü© := hK.elim_finite_subcover _ (Œª (x : K), hU x.val) hUK,
  let C : t ‚Üí set Œ± := Œª i, K ‚à© closure (U ((i : K) : Œ±)),
  have hC : K ‚äÜ ‚ãÉ i, C i,
  { rw [‚Üê K.inter_Union, subset_inter_iff],
    refine ‚ü®rfl.subset, ht.trans _‚ü©,
    simp only [set_coe.forall, subtype.coe_mk, Union_subset_iff],
    intros x hx‚ÇÅ hx‚ÇÇ,
    apply subset_subset_Union (‚ü®_, hx‚ÇÇ‚ü© : t),
    simp [subset_closure], },
  have hfC : ‚àÄ (i : t), f '' C i ‚äÜ ball (f ((i : K) : Œ±)) W,
  { rintros ‚ü®‚ü®x, hx‚ÇÅ‚ü©, hx‚ÇÇ‚ü©,
    calc f '' (K ‚à© closure (U x))
          ‚äÜ f '' (closure (U x)) : by { mono, simp only [inter_subset_right], }
      ... ‚äÜ closure (f '' (U x)) : continuous_on.image_closure f.continuous.continuous_on
      ... ‚äÜ closure (ball (f x) Z) : by { mono, simp, }
      ... ‚äÜ ball (f x) W : by { intros y hy,
                                obtain ‚ü®z, hz‚ÇÅ,hz‚ÇÇ‚ü© := uniform_space.mem_closure_iff_ball.mp hy hZ‚ÇÅ,
                                rw mem_ball_symmetry hZ‚ÇÇ at hz‚ÇÅ,
                                exact ball_mono hZ‚ÇÉ _ (mem_ball_comp hz‚ÇÇ hz‚ÇÅ), }, },
  refine ‚ü®t,
          t.fintype_coe_sort,
          C,
          Œª i, hK.inter_right is_closed_closure,
          Œª i, ball (f ((i : K) : Œ±)) W,
          Œª i, is_open_ball _ hW‚ÇÑ,
          by simp [continuous_map.compact_open.gen, hfC, -image_subset_iff],
          _‚ü©,
  intros g hg x hx,
  apply hW‚ÇÉ,
  replace hx := mem_Union.mp (hC hx),
  obtain ‚ü®y, hy‚ü© := hx,
  rw mem_comp_rel,
  use f y,
  simp only [mem_Inter, continuous_map.compact_open.gen, mem_set_of_eq, image_subset_iff] at hg,
  refine ‚ü®_, mem_preimage.mp (hg y hy)‚ü©,
  simp only [image_subset_iff, mem_preimage] at hfC,
  specialize hfC y hy,
  rw [ball_eq_of_symmetry hW‚ÇÇ] at hfC,
  exact hfC,
end

/-- This should follow from the various lemmas above. -/
lemma compact_open_eq_uniform :
  (compact_convergence_topology : topological_space C(Œ±, Œ≤)) = continuous_map.compact_open :=
begin
  rw [compact_convergence_topology, continuous_map.compact_open],
  refine le_antisymm _ _;
  rw le_generate_from_iff_subset_is_open;
  simp only [and_imp, exists_prop, forall_exists_index, set_of_subset_set_of],
  { rintros - K hK U hU rfl,
    apply is_open_iff_forall_mem_open.2,
    intros f hf,
    obtain ‚ü®V, hV, hV', hVf‚ü© := uniform_gen_subset_compact_open K f hK hU hf,
    refine ‚ü®uniform_gen K V f, hVf, _, mem_uniform_gen_self K V f hV‚ü©,
    apply topological_space.generate_open.basic,
    refine ‚ü®K, hK, V, hV, hV', f, rfl‚ü©, },
  { rintros - K hK V hV hV' f rfl,
    apply is_open_iff_forall_mem_open.2,
    intros g hg,
    obtain ‚ü®W, W', hW, hW', hW‚ÇÅ, hW‚ÇÇ‚ü© := uniform_gen_foo K f hK V hV hV' hg,
    obtain ‚ü®Œπ, hŒπ, C, hC, U, hU, Hg1, Hg2‚ü© :=Inter_compact_open_gen_subset_uniform_gen _ _ g hK hW',
    haveI := hŒπ,
    refine ‚ü®‚ãÇ i, continuous_map.compact_open.gen (C i) (U i), _, _, Hg1‚ü©,
    { intros g' hg',
      apply uniform_gen_mono K V f _ hW‚ÇÅ,
      exact uniform_gen_nhd_basis K W f W' hW‚ÇÇ (Hg2 hg'), },
    { apply is_open_Inter,
      intros i,
      convert continuous_map.is_open_gen (hC i) (hU i),
      finish, }, },
end

/-- I believe the topology this induces is `compact_convergence_topology`. -/
instance : uniform_space C(Œ±, Œ≤) :=
{ uniformity := ‚®Ö (K : set Œ±) (hK : is_compact K) (V ‚àà ùì§ Œ≤) (hV : is_open V),
                  ùìü { p : C(Œ±, Œ≤) √ó C(Œ±, Œ≤) | ‚àÄ (x : Œ±), (p.1 x, p.2 x) ‚àà V },
  refl :=
    begin
      simp only [filter.le_principal_iff, filter.mem_principal, mem_set_of_eq, le_infi_iff,
        id_rel_subset],
      exact Œª s hs V hV hV' f x, refl_mem_uniformity hV,
    end,
  symm := by {simp, intros s hs V hV,   sorry}, -- trivial
  comp := by {simp, sorry}, -- trivial
  is_open_uniformity := sorry, /- Should be easily reduced to `compact_open_eq_uniform` -/ }
